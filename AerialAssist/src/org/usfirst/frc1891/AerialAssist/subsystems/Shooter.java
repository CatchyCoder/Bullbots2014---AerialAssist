// RobotBuilder Version: 1.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.
package org.usfirst.frc1891.AerialAssist.subsystems;
import edu.wpi.first.wpilibj.AnalogChannel;
import edu.wpi.first.wpilibj.DigitalInput;
import edu.wpi.first.wpilibj.SpeedController;
import edu.wpi.first.wpilibj.can.CANTimeoutException;
import org.usfirst.frc1891.AerialAssist.RobotMap;
import edu.wpi.first.wpilibj.command.Subsystem;
import org.bullbots.core.Jaguar;
import org.usfirst.frc1891.AerialAssist.Robot;

/**
 *
 */
public class Shooter extends Subsystem {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    DigitalInput loadSwitch = RobotMap.shooterloadSwitch;
    SpeedController shootMotor = RobotMap.shootershootMotor;
    DigitalInput shootSwitch = RobotMap.shootershootSwitch;
    AnalogChannel iRSensor2 = RobotMap.shooterIRSensor2;
    AnalogChannel iRSensor1 = RobotMap.shooterIRSensor1;
    AnalogChannel potentiometer = RobotMap.shooterpotentiometer;
    SpeedController angleMotor = RobotMap.shooterangleMotor;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    
    /*
    Shooter:
    1: winch needs to be ready to lock
    2: winch needs to be pulled down until it hits the loadServo (now its locked)
    3: winch needs to be unwound to release rope slack
    4: winch lock needs to be released to fire, as you do this, it should be "re-cocked"
    5: winch can now be pulled back down (start back at #2 is in "ready to lock" position)
    */
    
    private boolean 
            isCalibrated = false, 
            isLoaded = false, 
            isShooting = false,
            isLoading = false,
            winchLocked = false,
            tiltingShooter = false, 
            isDown,
            waited = false,
            fired = false;
    private final int 
            SHOOT_BUTTON = 1, 
            TILT_BUTTON = 2,
            POST_SHOOT_DELAY = 3000;
    private final double 
            minPotValue = 3.01, 
            maxPotValue = 4.73, 
            midPotValue = (minPotValue + maxPotValue) / 2, 
            potTolerance = 0.05,
            positionTolerance = -0.05;
    private final double ANGLE_MOTOR_SPEED = 0.25;
    
    protected void initDefaultCommand() {}
    
    public Shooter() {
        isDown = potentiometer.getVoltage() > midPotValue;
    }
    
    public void update() {
        updateShooting();
        updateTilting();
    }
    
    private void updateShooting() {
        try {
            // Shooter is loaded and ready to fire
            if(isLoaded) {
                System.out.println("LOADED");
                // Must use BOTH joysticks to shoot, only active when shooter is not tilting
                if(!tiltingShooter && 
                        Robot.oi.joystickController1.isButtonDown(SHOOT_BUTTON) && 
                        Robot.oi.joystickController2.isButtonDown(SHOOT_BUTTON)) {
                    isLoaded = false;
                    isShooting = true;
                }
            }
            // Shooter is in the middle of the shooting process
            else if(isShooting) {
                System.out.println("SHOOTING");
                // Shooting, then locking the winch
                fireAndLock();
                
                if(!waited) {
                    // Checking if the shooter position is back at 0
                    if(RobotMap.winchJags.getMasterJag().getPosition() >= positionTolerance) {
                        Thread.sleep(POST_SHOOT_DELAY);
                        waited = true;
                    }
                }
                // If the delay was implemented, and the winch is locked,
                // then its done shooting
                else if(winchLocked) isShooting = waited = false;
            }
            // Shooter is loading
            else if(isLoading) {
                System.out.println("LOADING");
                load();
            }
            // Shooter is ready to load (idle)
            else {
                System.out.println("READY TO LOAD");
                load();
            }
        } catch(CANTimeoutException e) {
            e.printStackTrace();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
    
    private void updateTilting() {
        if(!tiltingShooter) { // Awaiting a request to tilt
            if(Robot.oi.joystickController1.isButtonDown(TILT_BUTTON) || Robot.oi.joystickController2.isButtonDown(TILT_BUTTON)) {
                tiltingShooter = true;
            }
        }
        else { // Shooter is moving
            
            // Rounding value to 2 decimal places in order
            // not to overload the cRIO
            double roundedPotVoltage = Jaguar.roundValue(potentiometer.getVoltage());
            
            if(isDown) { // Move it up
                // If its in position
                if(roundedPotVoltage <= minPotValue + potTolerance) {
                    angleMotor.set(0.0);
                    isDown = false;
                    tiltingShooter = false;
                }
                // Otherwise keep moving the motor
                else angleMotor.set(-ANGLE_MOTOR_SPEED);
            }
            else { // Move it down
                // If its in position
                if(roundedPotVoltage >= maxPotValue - potTolerance) {
                    angleMotor.set(0.0);
                    isDown = true;
                    tiltingShooter = false;
                }
                // Otherwise keep moving the motor
                else angleMotor.set(ANGLE_MOTOR_SPEED);
            }
        }
    }
    
    public void fireAndLock() {
        shootMotor.set(1.0);
        winchLocked = false;
        
        // Waiting until the lock is released (fired)
        if(!fired) fired = !shootSwitch.get();
        
        // Now waiting until the motor is back on the
        // switch, then stopping the motor (locked)
        else if(shootSwitch.get()) {
            shootMotor.set(0.0);
            winchLocked = true;
            fired = false;
        }
    }
    
    public void load() {
        // So far the loading is the same as the calibrating,
        // so we just call calibrate() in order to load...
        // this might be changed later
        RobotMap.winchJags.calibrate();
    }
    
    public void calibrate() {
        RobotMap.winchJags.calibrate();
    }
    
    public boolean isCalibrated() {
        return isCalibrated;
    }
    
    public boolean isLoaded() {
        return isLoaded;
    }
    
    public boolean winchLocked() {
        return winchLocked;
    }
    
    public void setCalibrated(boolean value) {
       isCalibrated = value;
    }
    
    public void setLoaded(boolean value) {
       isLoaded = value;
    }
    
    public void setWaited(boolean value) {
        waited = value;
    }
    
    public void setLoading(boolean value) {
        isLoading = value;
    }
}
