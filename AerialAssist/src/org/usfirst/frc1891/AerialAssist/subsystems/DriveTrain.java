// RobotBuilder Version: 1.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.
package org.usfirst.frc1891.AerialAssist.subsystems;
import org.usfirst.frc1891.AerialAssist.Robot;
import org.usfirst.frc1891.AerialAssist.RobotMap;

/**
 *
 */
public class DriveTrain {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    
    private boolean isInverted = false;
  
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
	
        // Set the default command for a subsystem here.
        //setDefaultCommand(new MySpecialCommand());
    }
    
    public void driveUsingVoltage(double leftValue, double rightValue) {
        RobotMap.driveJags1.driveUsingVoltage(leftValue);
        RobotMap.driveJags2.driveUsingVoltage(rightValue);
    }
    
    public void driveUsingSpeed(double leftValue, double rightValue) {
        RobotMap.driveJags1.driveUsingSpeed(leftValue);
        RobotMap.driveJags2.driveUsingSpeed(rightValue);
    }
    
    public void driveUsingPosition(double leftValue, double rightValue) {
        RobotMap.driveJags1.driveUsingPosition(leftValue);
        RobotMap.driveJags2.driveUsingPosition(rightValue);
    }
    
    public void driveUsingCurrent(double leftValue, double rightValue) {
        RobotMap.driveJags1.driveUsingCurrent(leftValue);
        RobotMap.driveJags2.driveUsingCurrent(rightValue);
    }
    
    public void stop() {
       RobotMap.driveJags1.stop();
       RobotMap.driveJags2.stop();
    }
    
    /**
     * Used to update the drive train during Tele-operation. During
     * Autonomous mode the drive train is controlled automatically.
     */
    public void updateTeleop() {
        // Updating state of drive train
        checkState();
        
        // Switches what controller each side of the drive
        // train is controlled by
        if(isInverted) {
            driveUsingSpeed(Robot.oi.joystickController2.getYAxis() * Robot.currentSpeed, 
                -Robot.oi.joystickController1.getYAxis() * Robot.currentSpeed);
        }
        else {
            driveUsingSpeed(Robot.oi.joystickController1.getYAxis() * Robot.currentSpeed, 
                -Robot.oi.joystickController2.getYAxis() * Robot.currentSpeed);
        }
    }
    
    public void checkState() {
        // Flipping robot driving direction, if needed
        
        if(Robot.oi.joystickController1.isButtonDown(4) || 
                Robot.oi.joystickController2.isButtonDown(4)) {
            isInverted = false;
            // Making the speed value positive
            Robot.currentSpeed = Robot.MAX_POS_RPM;
        }
        else if(Robot.oi.joystickController1.isButtonDown(5) || 
                Robot.oi.joystickController2.isButtonDown(5)) {
            isInverted = true;
            // Making the speed value negative
            Robot.currentSpeed = Robot.MAX_NEG_RPM;
        }
    }
    
    public boolean isInverted() {
        return isInverted;
    }
}
